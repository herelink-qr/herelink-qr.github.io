<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>æç¤º</title>
  <style>
    body {
      font-family: sans-serif;
      display: flex;
      justify-content: center;
      align-items: center;
      min-height: 100vh;
      margin: 0;
      background-color: #f7f7f7;
    }

    .container {
      background-color: #fff;
      padding: 30px;
      border-radius: 8px;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
      text-align: center;
    }

    h1 {
      color: #333;
      margin-bottom: 20px;
    }

    p {
      color: #666;
      line-height: 1.6;
      margin-bottom: 25px;
    }

    .button {
      display: inline-block;
      padding: 12px 24px;
      background-color: #007bff;
      color: white;
      text-decoration: none;
      border-radius: 5px;
      font-weight: bold;
    }

    .wechat-tip {
      background: #40b2a8;
      z-index: 100;
      padding: 8px;
      border-radius: 8px;
      margin-right: 8px
    }

    .wechat-tip p {
      text-align: center;
      font-size: 14px;
      color: #fff
    }

    .wechat-tip p.content {
      text-align: center;
      font-size: 14px
    }

  </style>
</head>
<body>
<div class="container">
  <h1>è¯·æ³¨æ„</h1>
  <p>æ‚¨æ­£åœ¨å°è¯•æ‰“å¼€ä¸€ä¸ªå¤–éƒ¨é“¾æ¥ã€‚</p>
  <div id="link-container" style="display: none;">
    <span id="link-text"></span>
    <a id="external-link" href="#" class="button" rel="noopener noreferrer">ç‚¹å‡»æ‰“å¼€é“¾æ¥</a>
  </div>
  <div id="wechat-message" class="wechat-tip" style="display: none;">
    <p>è¯·ç‚¹å‡»å³ä¸Šè§’ </p>
    <p class="content"> é€‰æ‹©"åœ¨æµè§ˆå™¨ä¸­æ‰“å¼€" </p>
  </div>
  <div id="qrcode" style="margin-top: 20px; display: none"><div class="error">You need to enable JavaScript to use this page</div></div>
    <img id="qrcode-img" style="margin-top: 20px" src="" alt="qrcode"/>
</div>

<script>

  // ======= https://github.com/nayuki/QR-Code-generator, Copyright Â© 2024 Project Nayuki. (MIT License) =======
  // Minified version of https://github.com/nayuki/QR-Code-generator/releases/download/v1.8.0/qrcodegen-v1.8.0-es6.js using https://closure-compiler.appspot.com/
  'use strict';var qrcodegen;
  (function(q){function m(b,a,c){if(0>a||31<a||0!=b>>>a)throw new RangeError("Value out of range");for(--a;0<=a;a--)c.push(b>>>a&1)}function h(b){if(!b)throw Error("Assertion error");}class e{constructor(b,a,c,d){this.version=b;this.errorCorrectionLevel=a;this.modules=[];this.isFunction=[];if(b<e.MIN_VERSION||b>e.MAX_VERSION)throw new RangeError("Version value out of range");if(-1>d||7<d)throw new RangeError("Mask value out of range");this.size=4*b+17;b=[];for(a=0;a<this.size;a++)b.push(!1);for(a=0;a<
  this.size;a++)this.modules.push(b.slice()),this.isFunction.push(b.slice());this.drawFunctionPatterns();c=this.addEccAndInterleave(c);this.drawCodewords(c);if(-1==d)for(c=1E9,b=0;8>b;b++)this.applyMask(b),this.drawFormatBits(b),a=this.getPenaltyScore(),a<c&&(d=b,c=a),this.applyMask(b);h(0<=d&&7>=d);this.mask=d;this.applyMask(d);this.drawFormatBits(d);this.isFunction=[]}static encodeText(b,a){b=q.QrSegment.makeSegments(b);return e.encodeSegments(b,a)}static encodeBinary(b,a){b=q.QrSegment.makeBytes(b);
    return e.encodeSegments([b],a)}static encodeSegments(b,a,c=1,d=40,g=-1,f=!0){if(!(e.MIN_VERSION<=c&&c<=d&&d<=e.MAX_VERSION)||-1>g||7<g)throw new RangeError("Invalid value");for(;;c++){const p=8*e.getNumDataCodewords(c,a),n=k.getTotalBits(b,c);if(n<=p){d=n;break}if(c>=d)throw new RangeError("Data too long");}for(const p of[e.Ecc.MEDIUM,e.Ecc.QUARTILE,e.Ecc.HIGH])f&&d<=8*e.getNumDataCodewords(c,p)&&(a=p);f=[];for(var l of b){m(l.mode.modeBits,4,f);m(l.numChars,l.mode.numCharCountBits(c),f);for(const p of l.getData())f.push(p)}h(f.length==
          d);b=8*e.getNumDataCodewords(c,a);h(f.length<=b);m(0,Math.min(4,b-f.length),f);m(0,(8-f.length%8)%8,f);h(0==f.length%8);for(l=236;f.length<b;l^=253)m(l,8,f);let r=[];for(;8*r.length<f.length;)r.push(0);f.forEach((p,n)=>r[n>>>3]|=p<<7-(n&7));return new e(c,a,r,g)}getModule(b,a){return 0<=b&&b<this.size&&0<=a&&a<this.size&&this.modules[a][b]}drawFunctionPatterns(){for(var b=0;b<this.size;b++)this.setFunctionModule(6,b,0==b%2),this.setFunctionModule(b,6,0==b%2);this.drawFinderPattern(3,3);this.drawFinderPattern(this.size-
          4,3);this.drawFinderPattern(3,this.size-4);b=this.getAlignmentPatternPositions();const a=b.length;for(let c=0;c<a;c++)for(let d=0;d<a;d++)0==c&&0==d||0==c&&d==a-1||c==a-1&&0==d||this.drawAlignmentPattern(b[c],b[d]);this.drawFormatBits(0);this.drawVersion()}drawFormatBits(b){var a=b|=this.errorCorrectionLevel.formatBits<<3;for(let c=0;10>c;c++)a=a<<1^1335*(a>>>9);b=(b<<10|a)^21522;h(0==b>>>15);for(a=0;5>=a;a++)this.setFunctionModule(8,a,0!=(b>>>a&1));this.setFunctionModule(8,7,0!=(b>>>6&1));this.setFunctionModule(8,
          8,0!=(b>>>7&1));this.setFunctionModule(7,8,0!=(b>>>8&1));for(a=9;15>a;a++)this.setFunctionModule(14-a,8,0!=(b>>>a&1));for(a=0;8>a;a++)this.setFunctionModule(this.size-1-a,8,0!=(b>>>a&1));for(a=8;15>a;a++)this.setFunctionModule(8,this.size-15+a,0!=(b>>>a&1));this.setFunctionModule(8,this.size-8,!0)}drawVersion(){if(!(7>this.version)){var b=this.version;for(var a=0;12>a;a++)b=b<<1^7973*(b>>>11);b|=this.version<<12;h(0==b>>>18);for(a=0;18>a;a++){const c=0!=(b>>>a&1),d=this.size-11+a%3,g=Math.floor(a/
          3);this.setFunctionModule(d,g,c);this.setFunctionModule(g,d,c)}}}drawFinderPattern(b,a){for(let c=-4;4>=c;c++)for(let d=-4;4>=d;d++){const g=Math.max(Math.abs(d),Math.abs(c)),f=b+d,l=a+c;0<=f&&f<this.size&&0<=l&&l<this.size&&this.setFunctionModule(f,l,2!=g&&4!=g)}}drawAlignmentPattern(b,a){for(let c=-2;2>=c;c++)for(let d=-2;2>=d;d++)this.setFunctionModule(b+d,a+c,1!=Math.max(Math.abs(d),Math.abs(c)))}setFunctionModule(b,a,c){this.modules[a][b]=c;this.isFunction[a][b]=!0}addEccAndInterleave(b){var a=
          this.version,c=this.errorCorrectionLevel;if(b.length!=e.getNumDataCodewords(a,c))throw new RangeError("Invalid argument");const d=e.NUM_ERROR_CORRECTION_BLOCKS[c.ordinal][a],g=e.ECC_CODEWORDS_PER_BLOCK[c.ordinal][a];a=Math.floor(e.getNumRawDataModules(a)/8);const f=d-a%d,l=Math.floor(a/d);c=[];const r=e.reedSolomonComputeDivisor(g);for(let n=0,u=0;n<d;n++){let t=b.slice(u,u+l-g+(n<f?0:1));u+=t.length;const v=e.reedSolomonComputeRemainder(t,r);n<f&&t.push(0);c.push(t.concat(v))}let p=[];for(let n=
          0;n<c[0].length;n++)c.forEach((u,t)=>{(n!=l-g||t>=f)&&p.push(u[n])});h(p.length==a);return p}drawCodewords(b){if(b.length!=Math.floor(e.getNumRawDataModules(this.version)/8))throw new RangeError("Invalid argument");let a=0;for(let c=this.size-1;1<=c;c-=2){6==c&&(c=5);for(let d=0;d<this.size;d++)for(let g=0;2>g;g++){const f=c-g,l=0==(c+1&2)?this.size-1-d:d;!this.isFunction[l][f]&&a<8*b.length&&(this.modules[l][f]=0!=(b[a>>>3]>>>7-(a&7)&1),a++)}}h(a==8*b.length)}applyMask(b){if(0>b||7<b)throw new RangeError("Mask value out of range");
    for(let a=0;a<this.size;a++)for(let c=0;c<this.size;c++){let d;switch(b){case 0:d=0==(c+a)%2;break;case 1:d=0==a%2;break;case 2:d=0==c%3;break;case 3:d=0==(c+a)%3;break;case 4:d=0==(Math.floor(c/3)+Math.floor(a/2))%2;break;case 5:d=0==c*a%2+c*a%3;break;case 6:d=0==(c*a%2+c*a%3)%2;break;case 7:d=0==((c+a)%2+c*a%3)%2;break;default:throw Error("Unreachable");}!this.isFunction[a][c]&&d&&(this.modules[a][c]=!this.modules[a][c])}}getPenaltyScore(){let b=0;for(var a=0;a<this.size;a++){var c=!1,d=0,g=[0,
    0,0,0,0,0,0];for(var f=0;f<this.size;f++)this.modules[a][f]==c?(d++,5==d?b+=e.PENALTY_N1:5<d&&b++):(this.finderPenaltyAddHistory(d,g),c||(b+=this.finderPenaltyCountPatterns(g)*e.PENALTY_N3),c=this.modules[a][f],d=1);b+=this.finderPenaltyTerminateAndCount(c,d,g)*e.PENALTY_N3}for(a=0;a<this.size;a++){c=!1;d=0;g=[0,0,0,0,0,0,0];for(f=0;f<this.size;f++)this.modules[f][a]==c?(d++,5==d?b+=e.PENALTY_N1:5<d&&b++):(this.finderPenaltyAddHistory(d,g),c||(b+=this.finderPenaltyCountPatterns(g)*e.PENALTY_N3),c=
          this.modules[f][a],d=1);b+=this.finderPenaltyTerminateAndCount(c,d,g)*e.PENALTY_N3}for(a=0;a<this.size-1;a++)for(c=0;c<this.size-1;c++)d=this.modules[a][c],d==this.modules[a][c+1]&&d==this.modules[a+1][c]&&d==this.modules[a+1][c+1]&&(b+=e.PENALTY_N2);a=0;for(var l of this.modules)a=l.reduce((r,p)=>r+(p?1:0),a);l=this.size*this.size;l=Math.ceil(Math.abs(20*a-10*l)/l)-1;h(0<=l&&9>=l);b+=l*e.PENALTY_N4;h(0<=b&&2568888>=b);return b}getAlignmentPatternPositions(){if(1==this.version)return[];const b=Math.floor(this.version/
          7)+2,a=32==this.version?26:2*Math.ceil((4*this.version+4)/(2*b-2));let c=[6];for(let d=this.size-7;c.length<b;d-=a)c.splice(1,0,d);return c}static getNumRawDataModules(b){if(b<e.MIN_VERSION||b>e.MAX_VERSION)throw new RangeError("Version number out of range");let a=(16*b+128)*b+64;if(2<=b){const c=Math.floor(b/7)+2;a-=(25*c-10)*c-55;7<=b&&(a-=36)}h(208<=a&&29648>=a);return a}static getNumDataCodewords(b,a){return Math.floor(e.getNumRawDataModules(b)/8)-e.ECC_CODEWORDS_PER_BLOCK[a.ordinal][b]*e.NUM_ERROR_CORRECTION_BLOCKS[a.ordinal][b]}static reedSolomonComputeDivisor(b){if(1>
          b||255<b)throw new RangeError("Degree out of range");let a=[];for(var c=0;c<b-1;c++)a.push(0);a.push(1);c=1;for(let d=0;d<b;d++){for(let g=0;g<a.length;g++)a[g]=e.reedSolomonMultiply(a[g],c),g+1<a.length&&(a[g]^=a[g+1]);c=e.reedSolomonMultiply(c,2)}return a}static reedSolomonComputeRemainder(b,a){let c=a.map(d=>0);for(const d of b){const g=d^c.shift();c.push(0);a.forEach((f,l)=>c[l]^=e.reedSolomonMultiply(f,g))}return c}static reedSolomonMultiply(b,a){if(0!=b>>>8||0!=a>>>8)throw new RangeError("Byte out of range");
    let c=0;for(let d=7;0<=d;d--)c=c<<1^285*(c>>>7),c^=(a>>>d&1)*b;h(0==c>>>8);return c}finderPenaltyCountPatterns(b){const a=b[1];h(a<=3*this.size);const c=0<a&&b[2]==a&&b[3]==3*a&&b[4]==a&&b[5]==a;return(c&&b[0]>=4*a&&b[6]>=a?1:0)+(c&&b[6]>=4*a&&b[0]>=a?1:0)}finderPenaltyTerminateAndCount(b,a,c){b&&(this.finderPenaltyAddHistory(a,c),a=0);a+=this.size;this.finderPenaltyAddHistory(a,c);return this.finderPenaltyCountPatterns(c)}finderPenaltyAddHistory(b,a){0==a[0]&&(b+=this.size);a.pop();a.unshift(b)}}
    e.MIN_VERSION=1;e.MAX_VERSION=40;e.PENALTY_N1=3;e.PENALTY_N2=3;e.PENALTY_N3=40;e.PENALTY_N4=10;e.ECC_CODEWORDS_PER_BLOCK=[[-1,7,10,15,20,26,18,20,24,30,18,20,24,26,30,22,24,28,30,28,28,28,28,30,30,26,28,30,30,30,30,30,30,30,30,30,30,30,30,30,30],[-1,10,16,26,18,24,16,18,22,22,26,30,22,22,24,24,28,28,26,26,26,26,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28],[-1,13,22,18,26,18,24,18,22,20,24,28,26,24,20,30,24,28,28,26,30,28,30,30,30,30,28,30,30,30,30,30,30,30,30,30,30,30,30,30,30],[-1,17,
      28,22,16,22,28,26,26,24,28,24,28,22,24,24,30,28,28,26,28,30,24,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30]];e.NUM_ERROR_CORRECTION_BLOCKS=[[-1,1,1,1,1,1,2,2,2,2,4,4,4,4,4,6,6,6,6,7,8,8,9,9,10,12,12,12,13,14,15,16,17,18,19,19,20,21,22,24,25],[-1,1,1,1,2,2,4,4,4,5,5,5,8,9,9,10,10,11,13,14,16,17,17,18,20,21,23,25,26,28,29,31,33,35,37,38,40,43,45,47,49],[-1,1,1,2,2,4,4,6,6,8,8,8,10,12,16,12,17,16,18,21,20,23,23,25,27,29,34,34,35,38,40,43,45,48,51,53,56,59,62,65,68],[-1,1,1,2,4,4,4,5,6,8,8,
      11,11,16,16,18,16,19,21,25,25,25,34,30,32,35,37,40,42,45,48,51,54,57,60,63,66,70,74,77,81]];q.QrCode=e;class k{constructor(b,a,c){this.mode=b;this.numChars=a;this.bitData=c;if(0>a)throw new RangeError("Invalid argument");this.bitData=c.slice()}static makeBytes(b){let a=[];for(const c of b)m(c,8,a);return new k(k.Mode.BYTE,b.length,a)}static makeNumeric(b){if(!k.isNumeric(b))throw new RangeError("String contains non-numeric characters");let a=[];for(let c=0;c<b.length;){const d=Math.min(b.length-c,
            3);m(parseInt(b.substr(c,d),10),3*d+1,a);c+=d}return new k(k.Mode.NUMERIC,b.length,a)}static makeAlphanumeric(b){if(!k.isAlphanumeric(b))throw new RangeError("String contains unencodable characters in alphanumeric mode");let a=[],c;for(c=0;c+2<=b.length;c+=2){let d=45*k.ALPHANUMERIC_CHARSET.indexOf(b.charAt(c));d+=k.ALPHANUMERIC_CHARSET.indexOf(b.charAt(c+1));m(d,11,a)}c<b.length&&m(k.ALPHANUMERIC_CHARSET.indexOf(b.charAt(c)),6,a);return new k(k.Mode.ALPHANUMERIC,b.length,a)}static makeSegments(b){return""==
    b?[]:k.isNumeric(b)?[k.makeNumeric(b)]:k.isAlphanumeric(b)?[k.makeAlphanumeric(b)]:[k.makeBytes(k.toUtf8ByteArray(b))]}static makeEci(b){let a=[];if(0>b)throw new RangeError("ECI assignment value out of range");if(128>b)m(b,8,a);else if(16384>b)m(2,2,a),m(b,14,a);else if(1E6>b)m(6,3,a),m(b,21,a);else throw new RangeError("ECI assignment value out of range");return new k(k.Mode.ECI,0,a)}static isNumeric(b){return k.NUMERIC_REGEX.test(b)}static isAlphanumeric(b){return k.ALPHANUMERIC_REGEX.test(b)}getData(){return this.bitData.slice()}static getTotalBits(b,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   a){let c=0;for(const d of b){b=d.mode.numCharCountBits(a);if(d.numChars>=1<<b)return Infinity;c+=4+b+d.bitData.length}return c}static toUtf8ByteArray(b){b=encodeURI(b);let a=[];for(let c=0;c<b.length;c++)"%"!=b.charAt(c)?a.push(b.charCodeAt(c)):(a.push(parseInt(b.substr(c+1,2),16)),c+=2);return a}}k.NUMERIC_REGEX=/^[0-9]*$/;k.ALPHANUMERIC_REGEX=/^[A-Z0-9 $%*+.\/:-]*$/;k.ALPHANUMERIC_CHARSET="0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ $%*+-./:";q.QrSegment=k})(qrcodegen||={});
  (function(q){(function(m){class h{constructor(e,k){this.ordinal=e;this.formatBits=k}}h.LOW=new h(0,1);h.MEDIUM=new h(1,0);h.QUARTILE=new h(2,3);h.HIGH=new h(3,2);m.Ecc=h})(q.QrCode||(q.QrCode={}))})(qrcodegen||={});
  (function(q){(function(m){class h{constructor(e,k){this.modeBits=e;this.numBitsCharCount=k}numCharCountBits(e){return this.numBitsCharCount[Math.floor((e+7)/17)]}}h.NUMERIC=new h(1,[10,12,14]);h.ALPHANUMERIC=new h(2,[9,11,13]);h.BYTE=new h(4,[8,16,16]);h.KANJI=new h(8,[8,10,12]);h.ECI=new h(7,[0,0,0]);m.Mode=h})(q.QrSegment||(q.QrSegment={}))})(qrcodegen||={});

  // Returns a string of SVG code for an image depicting the given QR Code, with the given number
  // of border modules. The string always uses Unix newlines (\n), regardless of the platform.
  function toSvgString(qr, border, lightColor, darkColor) {
    if (border < 0)
      throw new RangeError("Border must be non-negative");
    let parts = [];
    for (let y = 0; y < qr.size; y++) {
      for (let x = 0; x < qr.size; x++) {
        if (qr.getModule(x, y))
          parts.push(`M${x + border},${y + border}h1v1h-1z`);
      }
    }
    return `<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<svg xmlns="http://www.w3.org/2000/svg" version="1.1" viewBox="0 0 ${qr.size + border * 2} ${qr.size + border * 2}" stroke="none">
	<rect width="100%" height="100%" fill="${lightColor}"/>
	<path d="${parts.join(" ")}" fill="${darkColor}"/>
</svg>
`;
  }

  // Thanks to @d3xbot for providing the numbers
  // ERROR_CORRECTION_LEVEL L â€“ up to 7% damage - MAX_BYTES: 2953
  // ERROR_CORRECTION_LEVEL M â€“ up to 15% damage - MAX_BYTES: 2331
  // ERROR_CORRECTION_LEVEL Q â€“ up to 25% damage - MAX_BYTES: 1663
  // ERROR_CORRECTION_LEVEL H â€“ up to 30% damage - MAX_BYTES: 1273
  let ERROR_CORRECTION_LEVEL = localStorage.getItem("ERROR_CORRECTION_LEVEL") || "H";
  let ecc_level = "TODO";
  let max_size_digits = "TODO";
  let max_size_alpha_numeric = "TODO";
  let max_size_byte = "TODO";
  let estimated_size_emoji = "TODO";

  const getMaxQrCodeLength = (character, ecc_level) => {
    const string = character.repeat(7089); // From https://en.wikipedia.org/wiki/QR_code#Information_capacity -> maximum numeric only value
    return getMaxQrCodeString(string, ecc_level).length;
  }

  const getMaxQrCodeString = (string_to_try_to_use, ecc_level) => {
    try {
      // First check whether the whole string fits
      qrcodegen.QrCode.encodeText(string_to_try_to_use, ecc_level);
      return string_to_try_to_use
    } catch {
      // If not, binary search for the cutof point
      let min = 0;
      let max = string_to_try_to_use.length;
      while (min < max) {
        const middle = Math.ceil((min + max) / 2);
        try {
          qrcodegen.QrCode.encodeText(string_to_try_to_use.slice(0, middle), ecc_level);
          // QR code generation worked -> set minimum to this size
          min = middle;
        } catch (ex) {
          // QR code generation failed -> set maximum to middle - 1
          max = middle - 1;
          //console.error(ex);
        }
        console.log(`Max length between ${min} and ${max} for ${string_to_try_to_use.slice(0, 10)}...`);
      }
      console.log(`Determined maxiumu length ${min} for ${string_to_try_to_use.slice(0, 10)}...`);
      return string_to_try_to_use.slice(0, min);
    }
  }


  const setEccLevel = (eccLevelString) => {
    const ECC_MAP = {
      "L": qrcodegen.QrCode.Ecc.LOW,
      "M": qrcodegen.QrCode.Ecc.MEDIUM,
      "Q": qrcodegen.QrCode.Ecc.QUARTILE,
      "H": qrcodegen.QrCode.Ecc.HIGH,
    }
    try {
      ecc_level = ECC_MAP[eccLevelString];
    } catch {
      console.warn(`Unknown error correction level '${eccLevelString}', defaulting to 'L' (low)`);
      ecc_level = qrcodegen.QrCode.Ecc.LOW;
    }
    max_size_digits = getMaxQrCodeLength("0", ecc_level);
    max_size_alpha_numeric = getMaxQrCodeLength("A", ecc_level);
    max_size_byte = getMaxQrCodeLength("a", ecc_level);
    estimated_size_emoji = getMaxQrCodeLength("ğŸ˜€", ecc_level);
  }
  console.log("Offline QR code generator by github.com/six-two - Version 2024-09-14 - Nayuki Engine")
  const get_or_default_int = (name, default_value) => {
    const stored = localStorage.getItem(name);
    if (stored != null) {
      try {
        return parseInt(stored);
      } catch (error) {
        console.warn(`Failed to parse stored entry for '${name}'`);
      }
    }
    return default_value;
  }

  // ================== Start of user settings ==================
  // You can modify these settings without breaking stuff

  // Allow users to enable the clipboard monitoring function. Set this to false to hide the checkbox
  let SHOW_CLIPBOARD_MONITORING_CONTROLS = true;

  // Size of the QR code in pixels. Set it to 0 to automatically fit the free space
  let QR_MIN_SIZE = get_or_default_int("QR_MIN_SIZE", 30); //in pixels
  let QR_MAX_SIZE = get_or_default_int("QR_MAX_SIZE", 40); // in pixels

  // If you want a border around the QR code (that will stay when you right click -> "Save image as..." the image, set this to something greater than zero)
  let QR_BORDER_SIZE = get_or_default_int("QR_BORDER_SIZE", 0); // in pixels
  let QR_BORDER_COLOR = localStorage.getItem("QR_BORDER_COLOR") || "#909090"; // standard html color codes
  // =================== End of user settings ===================

  document.addEventListener('DOMContentLoaded', function() {
    // This needs to be done after loading the library
    setEccLevel(ERROR_CORRECTION_LEVEL);

    const qrcode = document.getElementById("qrcode");

    const showQrCodeGenerationError = (message) => {
      // Bad practice, but XSS should not be possible
      qrcode.innerHTML = `<div class="error"><b>QR code generation failed:</b><br>${message}</div>`;
    }

    const updateQRCode = (text) => {
      if (!text) {
        showQrCodeGenerationError("You need to type some text in the input area! It will then be rendered as a QR code.");
        return
      }

      try {
        const qr_code_object = qrcodegen.QrCode.encodeText(text, ecc_level);
        console.log('encodeText', text);
        qrcode.innerHTML = toSvgString(qr_code_object, QR_BORDER_SIZE, "white", "black");
        document.querySelector("#qrcode-img").src = "data:image/svg+xml;base64," + btoa(qrcode.innerHTML);
      } catch (error) {
        console.log(error);
        let suggestions = '<li><a href="javascript:fixByCuttingTextOfAfterQrCodeMaximumSize()">Cut off the input that does not fit into the QR code</a>';
        if (/[^A-Z0-9 $%*+.\/:-]+/.test(text)) {
          // Contains non alphanum characters
          suggestions += '<li><a href="javascript:tryFixByConvertingToAlphaNum()">Convert to alpha numeric: Try to map Unicode to nearest ASCII character, make all letters uppercase and remove all special or unicode characters except for "$%*+-./:"</a>';
        }
        if (ecc_level != qrcodegen.QrCode.Ecc.LOW) {
          // The ecc level is not at the lowest setting
          suggestions += `<li><a href="javascript:setEccLevel('L')">Use the lowest error correction level</a>`
        }

        showQrCodeGenerationError(`Failed to generate the QR code! Your text is ${text.length} characters long. Please try a shorter text and try removing special characters and emojis. Maximum length depends on the contents and error correction level. With the current error correction level you can fit the following number of characters:

<ul>
<li>digits (<i>0123456789</i>) -> ${max_size_digits}
<li>alphanumeric (<i>0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ $%*+-./:</i>) -> ${max_size_alpha_numeric}
<li>byte (<i>Any ASCII character</i>) -> ${max_size_byte}
<li>Emoji (<i>Stadard emoji without modifiers like ğŸ˜€</i>) -> Around ${estimated_size_emoji}
</ul>
<br>
The following functions can try to help:
<ul>
    ${suggestions}
</ul>
`);
        // console.error("Error while generating QR code", error);
      }
    };
    const hashHandle = (hashLink) => {
      let hashString = decodeURIComponent(hashLink);
      if (!hashString.startsWith("http")) {
        hashString = 'https://ss.here.link/' + hashString;
      }
      return hashString;
    }
    const onHashUpdate = () => {
      if (location.hash.length > 1) {
        let initial_value = location.hash.slice(1); // remove leading '#'
        externalLink.href = hashHandle(initial_value);
        linkText.innerText = externalLink.href;
        updateQRCode(location.href);
      }
    }
    // If the user changes the hash, we should update the text box with it
    window.addEventListener("hashchange", onHashUpdate);

    const fixByCuttingTextOfAfterQrCodeMaximumSize = () => {
      input_area.value = getMaxQrCodeString(input_area.value, ecc_level);
    }

    const tryFixByConvertingToAlphaNum = () => {
      input_area.value = unicodeToAlphanumericOnly(input_area.value);
    }

    const unicodeToAlphanumericOnly = (string) => {
      // Convert all whitespace to spaces
      string = string.replaceAll("\t", "    ").replaceAll(/\s/g, " ");

      // This rewrites the unicode so that Ã¤ becomes a + a diacritic mark. Later on we can drop the diacritic. This way we convert it to the nearest unicode character
      string = string.normalize("NFD");

      // The alphanumeric charset allows only uppercase characters, so we convert all lowercase ones
      string = string.toUpperCase();

      // Finally we drop all not allowed characters (or replace them with a place holder like '.'?)
      string = string.replaceAll(/[^A-Z0-9 $%*+.\/:-]+/g, "");

      return string;
    }
    window.test = unicodeToAlphanumericOnly;

    const linkContainer = document.getElementById('link-container');
    const externalLink = document.getElementById('external-link');
    const wechatMessage = document.getElementById('wechat-message');
    const linkText = document.getElementById('link-text');

    // è·å– URL hash ä¸­çš„é“¾æ¥
    const hashLink = window.location.hash.substring(1);

    if (hashLink) {
      externalLink.href = hashHandle(hashLink);
      linkText.innerText = externalLink.href;
      linkContainer.style.display = 'block';
    }

    // æ£€æµ‹æ˜¯å¦åœ¨å¾®ä¿¡ä¸­æ‰“å¼€
    function isWeChat() {
      return navigator.userAgent.toLowerCase().indexOf('micromessenger') !== -1 || navigator.userAgent.toLowerCase().indexOf('qq') !== -1;
    }
    function isPCBrowser() {
      const userAgent = navigator.userAgent.toLowerCase();

      // å¸¸è§çš„ PC æ“ä½œç³»ç»Ÿå…³é”®è¯
      const pcKeywords = ['windows', 'macintosh', 'linux', 'x11'];

      // å¸¸è§çš„ç§»åŠ¨è®¾å¤‡å…³é”®è¯
      const mobileKeywords = ['android', 'iphone', 'ipad', 'ipod', 'blackberry', 'iemobile', 'opera mini', 'mobi', 'tablet'];

      // å…ˆæ£€æŸ¥æ˜¯å¦åŒ…å« PC å…³é”®è¯
      const isLikelyPC = pcKeywords.some(keyword => userAgent.includes(keyword));

      // å†æ£€æŸ¥æ˜¯å¦åŒ…å«ç§»åŠ¨è®¾å¤‡å…³é”®è¯
      const isLikelyMobile = mobileKeywords.some(keyword => userAgent.includes(keyword));

      // å¦‚æœåŒ…å« PC å…³é”®è¯ä¸”ä¸åŒ…å«ç§»åŠ¨è®¾å¤‡å…³é”®è¯ï¼Œåˆ™è®¤ä¸ºæ˜¯ PC æµè§ˆå™¨
      return isLikelyPC && !isLikelyMobile;
    }

    if (hashLink) {
      updateQRCode(window.location.href);
    }

    if (isWeChat()) {
      // å¦‚æœåœ¨å¾®ä¿¡ä¸­æ‰“å¼€ï¼Œæ˜¾ç¤ºæç¤ºä¿¡æ¯
      wechatMessage.style.display = 'block';
      linkContainer.style.display = 'none'; // éšè—ç›´æ¥æ‰“å¼€é“¾æ¥çš„æŒ‰é’®
    } else if (hashLink) {
      // å¦‚æœä¸åœ¨å¾®ä¿¡ä¸­ï¼Œä¸”æœ‰é“¾æ¥ï¼Œåˆ™æ˜¾ç¤ºæ‰“å¼€é“¾æ¥çš„æŒ‰é’®
      wechatMessage.style.display = 'none';
      linkContainer.style.display = 'block';
      if (!isPCBrowser()) {
        // è‡ªåŠ¨æ‰“å¼€é“¾æ¥
        window.location.href = externalLink.href;
      }
    } else {
      wechatMessage.style.display = 'none';
      linkContainer.style.display = 'none';
      document.querySelector('.container').innerHTML = '<h1>æç¤º</h1><p>æœªæ£€æµ‹åˆ°éœ€è¦æ‰“å¼€çš„é“¾æ¥ã€‚</p>';
    }
  });
</script>
</body>
</html>